use axum_test::TestServer;
use diesel::prelude::*;
use http::StatusCode;
use payego_primitives::models::entities::enum_types::{CurrencyCode, PaymentState, TransactionIntent};
use payego_primitives::models::transaction::NewTransaction;
use payego_primitives::schema::{transactions, users};
use serial_test::serial;
use uuid::Uuid;

mod common;
use common::{create_test_app, create_test_app_state};

#[tokio::test]
#[serial]
async fn test_fetch_transaction_by_id_or_reference() {
    let state = create_test_app_state();

    // 1. Run migrations and cleanup
    {
        let mut conn = state.db.get().expect("Failed to get DB connection");
        common::run_test_migrations(&mut conn);
        common::cleanup_test_db(&mut conn);
    }

    let app = create_test_app(state.clone());
    let server = TestServer::new(app).unwrap();

    // 2. Register User to get Token and ID
    let email = format!("txn_fetch_{}@example.com", Uuid::new_v4());
    let register_response = server
        .post("/api/auth/register")
        .json(&serde_json::json!({
            "email": email,
            "password": "SecurePass123!",
            "username": Some(format!("user_{}", Uuid::new_v4()))
        }))
        .await;
    
    register_response.assert_status(StatusCode::CREATED);
    let token = register_response.json::<serde_json::Value>()["token"].as_str().unwrap().to_string();
    
    // Get User ID from DB
    let mut conn = state.db.get().unwrap();
    let user = users::table
        .filter(users::email.eq(&email))
        .first::<payego_primitives::models::user::User>(&mut conn)
        .unwrap();
    let user_id = user.id;

    // 3. Create a Transaction Manually
    // let tx_id = Uuid::new_v4();
    let tx_ref = Uuid::new_v4();
    
    diesel::insert_into(transactions::table)
        .values(NewTransaction {
            user_id,
            counterparty_id: None,
            intent: TransactionIntent::TopUp,
            amount: 1000,
            currency: CurrencyCode::USD,
            txn_state: PaymentState::Completed,
            provider: None,
            provider_reference: None,
            idempotency_key: "test_idempotency_key",
            reference: tx_ref, 
            description: Some("Test Transaction"),
            metadata: serde_json::json!({}),
        })
        .execute(&mut conn)
        .unwrap();
    
    // We need to fetch the inserted ID because `NewTransaction` doesn't let us specify `id` (it's autogenerated usually, but wait, schema says `id -> Uuid`).
    // Actually `transactions` table has `id`. `NewTransaction` struct in `payment_service.rs` usually relies on default or return.
    // Let's check `Transaction` struct or schema. Warning said `id` is primary key.
    // In `payment_service.rs` it uses `returning(transactions::id)`.
    // Let's retrieve the ID of the inserted transaction properly.
    let created_tx = transactions::table
        .filter(transactions::reference.eq(tx_ref))
        .first::<payego_primitives::models::transaction::Transaction>(&mut conn)
        .unwrap();
    
    let real_tx_id = created_tx.id;

    // 4. Fetch by ID
    let response_id = server
        .get(&format!("/api/transactions/{}", real_tx_id))
        .add_header("Authorization", &format!("Bearer {}", token))
        .await;
    response_id.assert_status(StatusCode::OK);
    let json_id: serde_json::Value = response_id.json();
    assert_eq!(json_id["id"], tx_ref.to_string());

    // 5. Fetch by Reference
    let response_ref = server
        .get(&format!("/api/transactions/{}", tx_ref))
        .add_header("Authorization", &format!("Bearer {}", token))
        .await;
    response_ref.assert_status(StatusCode::OK);
    let json_ref: serde_json::Value = response_ref.json();
    assert_eq!(json_ref["id"], tx_ref.to_string());
}
